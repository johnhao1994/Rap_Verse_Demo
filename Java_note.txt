异常：
是对问题的描述，将问题进行对象的封装
-----------------------------------------------------------
异常体系：
		Throwable
			--Error
			--Exception
				--RuntimeException

异常体系的特点：异常体系中的所有类及建立的对象都具备可抛性
可以被throw和throws关键字操作
throw定义在函数内
throws定义在函数上，可抛出多个异常，用逗号隔开


当函数内容有throw抛出异常对象，并未进行catch处理，必须要在函数上声明(即有throws)，否则编译失败
注意，RuntimeException除外，也就是函数如果抛出的是RuntimeException异常，函数上可以不用声明
-------------------------------------------------------------------------------------------------
如果函数声明了异常，调用者需要处理（try或者throws）

异常有两种：
			编译时被检测异常
				该异常在编译时，如果没有处理，编译失败
				该异常被表示，代表者可以被处理
			运行时异常（编译时不检测）
				在编译时不需要处理，编译不检查
				该异常的发生建议不处理，让程序停止，需要对代码进行修正
-------------------------------------------------------------------------------------------------------
处理异常的方式：
1.
try                   
{
}
catch()
{
}
2.
try
{
}
finally
{
}
3.
try
{
}
catch
{
}
				
注意：
1.对于处理异常代码的finally是一定会执行的，通常在里面定义的是关闭资源代码，因为资源必须释放
2.finally只有一种情况不会执行，当执行到System.exit(0);表示虚拟机直接结束，就不会执行finally中的代码，
3.throw在函数中单独存在时，下面不能放语句像return一样，不然无法通过编译
----------------------------------------------------------------------------------
自定义异常
	定义类一般继承Exception或者RuntimeException
	1.为了让该自定义类具有可抛性
	2.让该类具备操作异常的共性方法
	
	当要自定义异常的信息时，可以使用父类已经定义好的功能，异常信息传递给父类的构造函数
	
	class Myexception extends Exception
	{
		Myexception(String message)
		{
			super(message);
		}
	}
	
自定义异常是按照java的面向对象思想，将程序中的特有问题进行封装
----------------------------------------------------------------------------------------------
异常的好处：
1.将问题进行封装
2.将正常流程代码和问题处理代码相分离，方便阅读

---------------------------------------------------------------------------------------
异常处理原则：
	1.调用到抛出异常的功能时，抛出几个，就catch几个
	2.多个catch，父类Exception的catch放到最下面
	3.catch内要定义针对性的处理方式，不要定义简单的输出语句，可以输出到异常日志

	当捕获到的异常，本功能处理不了时，可以继续在catch中抛出
	try
	{
		throw new AException();
	}
	catch (AException e)
	{
		throw e;
	}
	如果该异常处理不了，但并不属于该功能出现的异常，可以将异常转换后在抛出和功能相关的异常
	
	或者异常可以处理，需要将异常产生的和本功能相关的问题提供出去，让调用者知道，并处理
		try
	{
		throw new AException();
	}
	catch (AException e)
	{
		throw new Bexception;
	}	
------------------------------------------------------------------------------------------------
异常的注意事项：
在子父类覆盖时：
	1.子类抛出的异常必须是父类的异常的子类或者子集
	2.如果父类或者接口没有异常抛出，子类覆盖出现异常只能try不能抛
-----------------------------------------------------------------------------------------------------
重要例子1：

1.老师用电脑上课
分析：
创建老师对象，校长调用老师的讲课方法-->老师对象调用电脑的运行方法-->

-->1.如果电脑出现蓝屏异常则重启

-->2.如果电脑出现冒烟异常,老师处理不了，调用布置练习方法并抛出课时无法按时完成异常

-->校长catch到老师的课时无法按时完成的异常，进行换老师操作

class BluescreenException extends Exception
{
	BluescreenException(String message)
	{
		super(message);
	}
}

class SmoingException extends Exception
{	
	SmoingException(String message)
	{
		super(message);
	}
}

class NoPlanException extends Exception
{
	NoPlanException(String msg)
	{
		super(msg);
	}
}

class Computer
{	private int state = 1;
	public void run() throws BluescreenException,SmoingException
	{	if(state == 2)
		{
			throw new BluescreenException("蓝屏了");
		}
		if(state == 3)
		{
			throw new SmoingException("冒烟了")；
		}
		System.out.println("电脑运行")；
	}
	public void restart()
	{	
		state = 1;
		System.out.println("电脑重启")；
	}
}

class Teacher
{
	private String name;
	Teacher(String name)
	{	
		this.name = name;
		cmpt = new Computer();
	}
	public void prelect() throws NoPlanException
	{	
		try
		{
			cmpt.run();
		}
		catch(BluescreenException e)
		{
			cmpt.restart()
		}
		catch(SmoingException e)
		{	
			test();
			throw new NoPlanException("课时无法继续"+e.getMessage());
		}
		System.out.println("开始讲课")；
	}
	public void test()
	{
		System.out.println("练习")；
	}
	
}

class ExceptionTest
{
	public static void main(String[] args)
	{
		Teacher t = new Teacher("毕老师")；
		try
		{
			t.prelect();
		}
		catch(NoPlanException e)
		{
			System.out.println(e.toString);
			System.out.println("换老师")；
		}
	}	
}
-------------------------------------------------------------------------------------------------------------
重要例子2：


如果出现非法数值，后面的运算与操作没有意义要让程序立即停掉，
interface Graph
{
	void getArea();
}

class illeagleException extends RuntimeException
{
	illeagleException(string message)
	{
		super(message);
	}
}
class Rec implements Graph
{
	private int len,wid;
	Rec(int len,int wid)
	{	if(len <= 0 || wid <= 0)
		{
			throw new illeagleException("出现非法值")；
		}
		this.len = len;
		this.wid = wid;
	}
	public void getArea()
	{
		System.out.println(len*wid);
	}
}

class Cicle implements Graph
{
	private int radius;
	public static final PI = 3.14;
	Circle(int radius)
	{	
		if (radius <= 0)
		{
			throw illeagleException("出现非法值")；
		}
		this.radius = radius;
		
	}
	public void getArea
	{
		System.out.println(radius*radius*PI)
	}
}
class ExceptionTest2
{
		public static void main(String[] args)
		{
				Rec r = new Rec(3,4);
				r.getArea();
		}
}

--------------------------------------------------------------------------------------------------------
                                       Java包的内容
------------------------------------------------------------------------------------------------------

总结：
一个.java中只能有一个puclic class

类名的全名是包名.类名（注意完整性）

pack包如果不在当前目录下，需要设置classpath，告诉jvm去哪里找指定的包


包与包之间进行访问，被访问的包中的类以及类中的成员需要public修饰

不同的包中的子类还可以直接访问父类中被protected权限修饰的成员,也就是说如果某个包中的类A用protected修饰，那么在其他包中的类如果不是A的子类则不能访问A类中的成员

包与包之间可以使用的权限只有两种，public  protected

			public		protected	default		private
同一个类中   √				√			√			√
同一个包中	 √				√			√			X
子类		 √				√
不同包中	 √				


为了简化类名的书写，使用一个关键字，import
import 包名.包名.????.*  表示将该包中的类全部导入，注意导入的仅是类 ，子包不会导入

建议不要写写通配符*

建议定义包名时不要重复，可以使用Url完成定义，Url是唯一的

-------------------------------------------------------------------------------------------------
                                       jar包
-------------------------------------------------------------------------------------------------






--------------------------------------------------------------------------------------------------
                                        线程
--------------------------------------------------------------------------------------------------
多线程同时执行，提高效率
创建多线程办法

1.继承Thread类，并覆盖run方法，run方法中存放多线程要执行的内容


class Test extends Thread
{
	Test(String name)
	{
		super(name);
	}

	public void run()
	{
		for(int x=0; x<60; x++)
		{
			System.out.println("test run"+ x);
		}
	}
}

class TestDemo
{
	public static void main(String [] args)
	{
		Test t1 = new Test();
		Test t2 = new Test();
		t1.start(); //子线程
		t2.start();  //子线程
		
		for (int x = 0; x<60; x++)    //主线程
		{
			System.out.println("main" + x);
		}

	}
}

线程运行状态：

             
                               阻塞状态（具备运行资格，但还有没执行权）
                                   ^						  ^	   
							      /                            \
								 /		                        \
                                /                                \
被创建——————————————————————>运行——————————————————————————————>冻结
          start()              |              sleep(time)
							   |			   wait()		(注意：wait 会将线程挂起，一直等待，而sleep时间到了就会醒来会进入阻塞或者运行状态)
	   	                       |              ————————————>
							   |			<————————————————
							   |				  notify()或者sleep时间到
							   |
							   |
							   |
							   |   stop()或者run方法结束
							   |
							   v
							  消亡 
							  
Thread类中的方法：
static Thread currentThread():获取当前线程对象
getName():获取线程名称

设置线程名称：setName或者构造函数
P.S 局部的变量在每个线程区域中都有独立的一份

2.创建线程的第二种方式：实现Runable接口

1.定义类实现Runable接口
2.覆盖Runable接口中的run方法
将线程要运行的代码存放在该run方法中

3.通过Thread类建立线程对象
4.将Runable接口的子类对象作为实际参数传递给Thread类的构造函数

5.调用Thread类的start方法开启线程并调用Runable接口子类的的run方法	

实现方式和继承方式有什么区别：
实现方式：避免了单继承的局限性
在定义线程时建议使用实现的方式

class Ticket implements Runnable
{
	private int ticket = 100;
	public void run()
	{
		while(true)
		{
			if (ticket > 0)
			{
				System.out.println(Thread.currentThread().getName() + ".....sale" + ticket--);
			}
		}
	}
}

class TestDemo
{
	public static void main(String [] args)
	{
		Ticket t = new Ticket();
		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);
		Thread t3 = new Thread(t);
		Thread t4 = new Thread(t);
		t1.start();
		t2.start();
		t3.start();
		t4.start();

	}
}
多线程带来的安全隐患：
	当多条语句在同一个线程共享数据时，一个线程对多条语句只执行了一部分还没有执行完时
	另一个线程参与进来执行，导致共享数据的错误 

解决办法：
		对多条操作共享数据的语句，只能让一个线程都执行完。在执行过程中别的线程不能参与执行
		
java中提供的解决办法：
同步代码块

synchronized(对象)
{
	需要被同步的代码
}
对象如同锁，持有锁的线程可以在同步中执行。
没有持有锁的线程即使获得cpu的执行权也进行不下去，因为没有锁

同步的前提：
必须要有两个或两个以上的线程
必须是多个线程使用同一个锁

好处：解决了多线程的安全问题
弊端：多个线程需要判断锁，较为消耗资源

也可以让函数有同步的特性，用关键字synchronized修饰函数，不过同步函数使用的锁是this

同步函数被静态修饰后，使用的锁是该方法所在类的字节码文件对象。类名.class 类型是Class

写一个延迟加载的单例设立模式 懒汉式
class Single
{
	private static Single s = null;
	private Single(){}
	public static Single getInstance()   //同步函数的方式：public static synchronized Single getInstance()   
	{
		if(s==null)
		{
			synchronized(Single.class)
			{
				if (s==null)
					s = new Single();
			}
		}
		return s;
	}
}

死锁问题：
同步中嵌套同步，锁却不同
=================================================================================
线程间通信
=================================================================================
线程间通讯：
多个线程在操作同一个资源，但是操作的动作不同
===========================================================
示例：
class Res
{
	private String name;
	private String sex;
	private boolean flag = false;
	private Lock = new ReentrantLock();
	private Condition condition_pro = lock.newCondition();
	private Condition condition_con = lock.newCondition();
	public  void set (String name,String sex) throws InterruptedException
	{	 	lock.lock();
			while (flag)
				condition_pro.await();
						this.name = name;
						this.sex =sex;
						flag = true;
						condition_con.signal();
					finally
					{
						lock.unlock();
					}
						
	}
	public synchronized void out()
	{	lock.lock(); 
		try
		{
			while(!flag)
				condition_con.await();
			System.out.println(Thread.currentThread().getName()+this.name+this.sex)
			flag = flase;
			condition_pro.signal();
		}
		finally
		{
			lock.unlock();
		}
	}
}
class Input implements Runnable
{
	private Res r;
	Input(Res r)
	{
		this.r = r;
	}
	public void run()
	{
		int x = 0;
		while(true)
		{	    
			try
			{
				if (x==0)
				{	
					r.set = ("mike","male");
				}
					else
					{	
						r.set = ("丽丽","女女"）;
					}
			x= (x+1)%2;
			}
				catch(InterruptedException e)
				{}
		
			}
		}
	}
}

class Output implements Runnable
{
	private Res r;
	Output (Res r)
	{	
		this.r =r;
	}
	public void run()
	{	
		{	
			while (true)
			{
				try
				{
					r.out();
				}
				catch(InterruptedException e)
			}
		
		}
	}
	
}

class InputOutputDemo
{
	public static void main(Strin[] args)
	{
		Res r = new Res();
		new Thread(new Input(r)).start();
		new Thread(new output(r)).start();
	}
}
/*
wait() 
notify()
notifyAll()
都使用在同步中，因为要对持有锁的线程操作，所以要使用在同步中，因为只有同步才具有锁
 
为什么这些操作线程的方法要定义在Object类中呢：
因为这些方法在操作同步中线程时，都必须要标识它们所操作的线程的锁
只有同一个锁上的被等待线程，可以被同一个锁上notify唤醒
不可以对不同锁中的线程进行唤醒

也就是说等待和唤醒必须是同一个锁

而锁可以使任意对象，所以被任意对象调用的方法定义在Object类中

若线程数大于两个，必须使用while判断并且notifyAll()

JDK1.5中提供了多线程升级解决方案，将同步Synchronized替换成现实Lock操作

将Object中的wait,notify,notifyALL替换了condition对象
该对象可以Lock锁进行获取  

该示例中实现了本方只唤醒对方操作

注意有了lock必须finally中unlock，释放锁的操作一定要执行
*/
=========================================================
停止线程
===========================================================
stop方法过时，用run方法结束
只要控制住循环，就可以子线程中的让run方法里的循环结束，也就是线程结束
特殊情况：
当线程处于冻结状态，就不会读取到标记，那么线程就不会结束

当没有指定的方式让冻结的线程恢复到运行状态时，这时需要对冻结状态进行清除，强制让线程恢复到运行状态
这时可以操作标记让让线程结束

==========================================================
class StopThread implements Runnable
{
	private boolean flag = true;
	public void run()
	{	
		while(flag)
		{	
		/* try
			{
				wait();
			}
			catch(InterruptedException e)
			{
				System.out.println(Thread.currentThread.getName+"....Exception");
				flag = false;
			}
		
		*/
		
		
			System.out.println(Thread.currentThread().getName()+".....run");
		}
	}
	public void chageFlag()
	{
		flag = false;
	}
	
}
class StopThreadDemo
{
	public static void main(String[] args)
	{
		StopThread st = new StopThread();
		t1.setDaemon(true);
		t2.setDaemon(true);
		Thread t1 = new Thread(st);
		Thread t2 = new Thread(st);
		t1.start();
		t2.start();
		int num = 0;
		while(true)
		{
			if (num++ == 60)
			{
				st.changeFlag();
				break;
			}
			System.out.println(Thread.currentThread().getName()+".......run");
		}
	}
}
===================================================================================================
setDaemon(true);将该线程变为后台线程（守护线程），在线程开启前使用
join()方法:
当A线程执行到了B线程.join()方法时，A就会等待，等B线程都执行完A才会执行
join()可以用于临时加入线程

线程优先级1-10，通过方法setPriority()来调整


=====================================================================================================
class StopThread implements Runnable
{
	private boolean flag = true;
	public void run()
	{	
		while(flag)
		{	
		System.out.println(Thread.currentThread().getName()+".....run");
		//Thread.yield();临时释放该线程执行权，可以稍微减缓该线程的出现频率，使其不会连续获得执行权
		}
	}
	public void chageFlag()
	{
		flag = false;
	}
	
}
class StopThreadDemo
{
	public static void main(String[] args)
	{
		StopThread st = new StopThread();
		t1.setDaemon(true);
		t2.setDaemon(true);
		// t1.setPriority(Thread.MAX_PRIORITY);设置t1线程优先级最高
		Thread t1 = new Thread(st);
		Thread t2 = new Thread(st);
		t1.start();
		t2.start();
		int num = 0;
		while(true)
		{
			if (num++ == 60)
			{
				break;
			}
			System.out.println(Thread.currentThread().getName()+".......run");
		}
	}
}
=========================================================
当某些代码需要同时被执行时，可以用多线程执行，可以用匿名类完成，使代码更简洁
=================================
class ThreadTest
{
	public static void main(String[] args)
	{
		new Thread()
		{
			public void run()
			{
				for (int i = 0;i<100;i++)
				{
					System.out.prinln(Thread.currentThread().getName()+"....."+x);
				}
			}
		}.start();
		
		for (int i = 0;i<100;i++)
			{
				System.out.prinln(Thread.currentThread().getName()+"....."+x);
			}
		Runnable r = new Runnable()
		{
			public void run()
			{
				for (int i = 0;i<100;i++)
				{
					System.out.prinln(Thread.currentThread().getName()+"....."+x);
				}
			}
		};
			new Thread(r).start();
	}
}