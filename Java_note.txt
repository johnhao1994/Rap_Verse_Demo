异常：
是对问题的描述，将问题进行对象的封装
-----------------------------------------------------------
异常体系：
		Throwable
			--Error
			--Exception
				--RuntimeException

异常体系的特点：异常体系中的所有类及建立的对象都具备可抛性
可以被throw和throws关键字操作
throw定义在函数内
throws定义在函数上，可抛出多个异常，用逗号隔开


当函数内容有throw抛出异常对象，并未进行catch处理，必须要在函数上声明(即有throws)，否则编译失败
注意，RuntimeException除外，也就是函数如果抛出的是RuntimeException异常，函数上可以不用声明
-------------------------------------------------------------------------------------------------
如果函数声明了异常，调用者需要处理（try或者throws）

异常有两种：
			编译时被检测异常
				该异常在编译时，如果没有处理，编译失败
				该异常被表示，代表者可以被处理
			运行时异常（编译时不检测）
				在编译时不需要处理，编译不检查
				该异常的发生建议不处理，让程序停止，需要对代码进行修正
-------------------------------------------------------------------------------------------------------
处理异常的方式：
1.
try                   
{
}
catch()
{
}
2.
try
{
}
finally
{
}
3.
try
{
}
catch
{
}
				
注意：
1.对于处理异常代码的finally是一定会执行的，通常在里面定义的是关闭资源代码，因为资源必须释放
2.finally只有一种情况不会执行，当执行到System.exit(0);表示虚拟机直接结束，就不会执行finally中的代码，
3.throw在函数中单独存在时，下面不能放语句像return一样，不然无法通过编译
----------------------------------------------------------------------------------
自定义异常
	定义类一般继承Exception或者RuntimeException
	1.为了让该自定义类具有可抛性
	2.让该类具备操作异常的共性方法
	
	当要自定义异常的信息时，可以使用父类已经定义好的功能，异常信息传递给父类的构造函数
	
	class Myexception extends Exception
	{
		Myexception(String message)
		{
			super(message);
		}
	}
	
自定义异常是按照java的面向对象思想，将程序中的特有问题进行封装
----------------------------------------------------------------------------------------------
异常的好处：
1.将问题进行封装
2.将正常流程代码和问题处理代码相分离，方便阅读

---------------------------------------------------------------------------------------
异常处理原则：
	1.调用到抛出异常的功能时，抛出几个，就catch几个
	2.多个catch，父类Exception的catch放到最下面
	3.catch内要定义针对性的处理方式，不要定义简单的输出语句，可以输出到异常日志

	当捕获到的异常，本功能处理不了时，可以继续在catch中抛出
	try
	{
		throw new AException();
	}
	catch (AException e)
	{
		throw e;
	}
	如果该异常处理不了，但并不属于该功能出现的异常，可以将异常转换后在抛出和功能相关的异常
	
	或者异常可以处理，需要将异常产生的和本功能相关的问题提供出去，让调用者知道，并处理
		try
	{
		throw new AException();
	}
	catch (AException e)
	{
		throw new Bexception;
	}	
------------------------------------------------------------------------------------------------
异常的注意事项：
在子父类覆盖时：
	1.子类抛出的异常必须是父类的异常的子类或者子集
	2.如果父类或者接口没有异常抛出，子类覆盖出现异常只能try不能抛
-----------------------------------------------------------------------------------------------------
重要例子1：

1.老师用电脑上课
分析：
创建老师对象，校长调用老师的讲课方法-->老师对象调用电脑的运行方法-->

-->1.如果电脑出现蓝屏异常则重启

-->2.如果电脑出现冒烟异常,老师处理不了，调用布置练习方法并抛出课时无法按时完成异常

-->校长catch到老师的课时无法按时完成的异常，进行换老师操作

class BluescreenException extends Exception
{
	BluescreenException(String message)
	{
		super(message);
	}
}

class SmoingException extends Exception
{	
	SmoingException(String message)
	{
		super(message);
	}
}

class NoPlanException extends Exception
{
	NoPlanException(String msg)
	{
		super(msg);
	}
}

class Computer
{	private int state = 1;
	public void run() throws BluescreenException,SmoingException
	{	if(state == 2)
		{
			throw new BluescreenException("蓝屏了");
		}
		if(state == 3)
		{
			throw new SmoingException("冒烟了")；
		}
		System.out.println("电脑运行")；
	}
	public void restart()
	{	
		state = 1;
		System.out.println("电脑重启")；
	}
}

class Teacher
{
	private String name;
	Teacher(String name)
	{	
		this.name = name;
		cmpt = new Computer();
	}
	public void prelect() throws NoPlanException
	{	
		try
		{
			cmpt.run();
		}
		catch(BluescreenException e)
		{
			cmpt.restart()
		}
		catch(SmoingException e)
		{	
			test();
			throw new NoPlanException("课时无法继续"+e.getMessage());
		}
		System.out.println("开始讲课")；
	}
	public void test()
	{
		System.out.println("练习")；
	}
	
}

class ExceptionTest
{
	public static void main(String[] args)
	{
		Teacher t = new Teacher("毕老师")；
		try
		{
			t.prelect();
		}
		catch(NoPlanException e)
		{
			System.out.println(e.toString);
			System.out.println("换老师")；
		}
	}	
}
-------------------------------------------------------------------------------------------------------------
重要例子2：


如果出现非法数值，后面的运算与操作没有意义要让程序立即停掉，
interface Graph
{
	void getArea();
}

class illeagleException extends RuntimeException
{
	illeagleException(string message)
	{
		super(message);
	}
}
class Rec implements Graph
{
	private int len,wid;
	Rec(int len,int wid)
	{	if(len <= 0 || wid <= 0)
		{
			throw new illeagleException("出现非法值")；
		}
		this.len = len;
		this.wid = wid;
	}
	public void getArea()
	{
		System.out.println(len*wid);
	}
}

class Cicle implements Graph
{
	private int radius;
	public static final PI = 3.14;
	Circle(int radius)
	{	
		if (radius <= 0)
		{
			throw illeagleException("出现非法值")；
		}
		this.radius = radius;
		
	}
	public void getArea
	{
		System.out.println(radius*radius*PI)
	}
}
class ExceptionTest2
{
		public static void main(String[] args)
		{
				Rec r = new Rec(3,4);
				r.getArea();
		}
}

--------------------------------------------------------------------------------------------------------
                                       Java包的内容
------------------------------------------------------------------------------------------------------

总结：
一个.java中只能有一个puclic class

类名的全名是包名.类名（注意完整性）

pack包如果不在当前目录下，需要设置classpath，告诉jvm去哪里找指定的包


包与包之间进行访问，被访问的包中的类以及类中的成员需要public修饰

不同的包中的子类还可以直接访问父类中被protected权限修饰的成员,也就是说如果某个包中的类A用protected修饰，那么在其他包中的类如果不是A的子类则不能访问A类中的成员

包与包之间可以使用的权限只有两种，public  protected

			public		protected	default		private
同一个类中   √				√			√			√
同一个包中	 √				√			√			X
子类		 √				√
不同包中	 √				


为了简化类名的书写，使用一个关键字，import
import 包名.包名.????.*  表示将该包中的类全部导入，注意导入的仅是类 ，子包不会导入

建议不要写写通配符*

建议定义包名时不要重复，可以使用Url完成定义，Url是唯一的

-------------------------------------------------------------------------------------------------
                                       jar包
-------------------------------------------------------------------------------------------------






--------------------------------------------------------------------------------------------------
                                        线程
--------------------------------------------------------------------------------------------------
多线程同时执行，提高效率
创建多线程办法

1.继承Thread类，并覆盖run方法，run方法中存放多线程要执行的内容


class Test extends Thread
{
	Test(String name)
	{
		super(name);
	}

	public void run()
	{
		for(int x=0; x<60; x++)
		{
			System.out.println("test run"+ x);
		}
	}
}

class TestDemo
{
	public static void main(String [] args)
	{
		Test t1 = new Test();
		Test t2 = new Test();
		t1.start(); //子线程
		t2.start();  //子线程
		
		for (int x = 0; x<60; x++)    //主线程
		{
			System.out.println("main" + x);
		}

	}
}

线程运行状态：

             
                               阻塞状态（具备运行资格，但还有没执行权）
                                   ^						  ^	   
							      /                            \
								 /		                        \
                                /                                \
被创建——————————————————————>运行——————————————————————————————>冻结
          start()              |              sleep(time)
							   |			   wait()		(注意：wait 会将线程挂起，一直等待，而sleep时间到了就会醒来会进入阻塞或者运行状态)
	   	                       |              ————————————>
							   |			<————————————————
							   |				  notify()或者sleep时间到
							   |
							   |
							   |
							   |   stop()或者run方法结束
							   |
							   v
							  消亡 
							  
Thread类中的方法：
static Thread currentThread():获取当前线程对象
getName():获取线程名称

设置线程名称：setName或者构造函数
P.S 局部的变量在每个线程区域中都有独立的一份

2.创建线程的第二种方式：实现Runable接口

1.定义类实现Runable接口
2.覆盖Runable接口中的run方法
将线程要运行的代码存放在该run方法中

3.通过Thread类建立线程对象
4.将Runable接口的子类对象作为实际参数传递给Thread类的构造函数

5.调用Thread类的start方法开启线程并调用Runable接口子类的的run方法	

实现方式和继承方式有什么区别：
实现方式：避免了单继承的局限性
在定义线程时建议使用实现的方式

class Ticket implements Runnable
{
	private int ticket = 100;
	public void run()
	{
		while(true)
		{
			if (ticket > 0)
			{
				System.out.println(Thread.currentThread().getName() + ".....sale" + ticket--);
			}
		}
	}
}

class TestDemo
{
	public static void main(String [] args)
	{
		Ticket t = new Ticket();
		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);
		Thread t3 = new Thread(t);
		Thread t4 = new Thread(t);
		t1.start();
		t2.start();
		t3.start();
		t4.start();

	}
}
多线程带来的安全隐患：
	当多条语句在同一个线程共享数据时，一个线程对多条语句只执行了一部分还没有执行完时
	另一个线程参与进来执行，导致共享数据的错误 

解决办法：
		对多条操作共享数据的语句，只能让一个线程都执行完。在执行过程中别的线程不能参与执行
		
java中提供的解决办法：
同步代码块

synchronized(对象)
{
	需要被同步的代码
}
对象如同锁，持有锁的线程可以在同步中执行。
没有持有锁的线程即使获得cpu的执行权也进行不下去，因为没有锁

同步的前提：
必须要有两个或两个以上的线程
必须是多个线程使用同一个锁

好处：解决了多线程的安全问题
弊端：多个线程需要判断锁，较为消耗资源

也可以让函数有同步的特性，用关键字synchronized修饰函数，不过同步函数使用的锁是this

同步函数被静态修饰后，使用的锁是该方法所在类的字节码文件对象。类名.class 类型是Class

写一个延迟加载的单例设立模式 懒汉式
class Single
{
	private static Single s = null;
	private Single(){}
	public static Single getInstance()   //同步函数的方式：public static synchronized Single getInstance()   
	{
		if(s==null)
		{
			synchronized(Single.class)
			{
				if (s==null)
					s = new Single();
			}
		}
		return s;
	}
}

死锁问题：
同步中嵌套同步，锁却不同
=================================================================================
线程间通信
=================================================================================
线程间通讯：
多个线程在操作同一个资源，但是操作的动作不同
===========================================================
示例：
class Res
{
	private String name;
	private String sex;
	private boolean flag = false;
	private Lock = new ReentrantLock();
	private Condition condition_pro = lock.newCondition();
	private Condition condition_con = lock.newCondition();
	public  void set (String name,String sex) throws InterruptedException
	{	 	lock.lock();
			while (flag)
				condition_pro.await();
						this.name = name;
						this.sex =sex;
						flag = true;
						condition_con.signal();
					finally
					{
						lock.unlock();
					}
						
	}
	public synchronized void out()
	{	lock.lock(); 
		try
		{
			while(!flag)
				condition_con.await();
			System.out.println(Thread.currentThread().getName()+this.name+this.sex)
			flag = flase;
			condition_pro.signal();
		}
		finally
		{
			lock.unlock();
		}
	}
}
class Input implements Runnable
{
	private Res r;
	Input(Res r)
	{
		this.r = r;
	}
	public void run()
	{
		int x = 0;
		while(true)
		{	    
			try
			{
				if (x==0)
				{	
					r.set = ("mike","male");
				}
					else
					{	
						r.set = ("丽丽","女女"）;
					}
			x= (x+1)%2;
			}
				catch(InterruptedException e)
				{}
		
			}
		}
	}
}

class Output implements Runnable
{
	private Res r;
	Output (Res r)
	{	
		this.r =r;
	}
	public void run()
	{	
		{	
			while (true)
			{
				try
				{
					r.out();
				}
				catch(InterruptedException e)
			}
		
		}
	}
	
}

class InputOutputDemo
{
	public static void main(Strin[] args)
	{
		Res r = new Res();
		new Thread(new Input(r)).start();
		new Thread(new output(r)).start();
	}
}
/*
wait() 
notify()
notifyAll()
都使用在同步中，因为要对持有锁的线程操作，所以要使用在同步中，因为只有同步才具有锁
 
为什么这些操作线程的方法要定义在Object类中呢：
因为这些方法在操作同步中线程时，都必须要标识它们所操作的线程的锁
只有同一个锁上的被等待线程，可以被同一个锁上notify唤醒
不可以对不同锁中的线程进行唤醒

也就是说等待和唤醒必须是同一个锁

而锁可以使任意对象，所以被任意对象调用的方法定义在Object类中

若线程数大于两个，必须使用while判断并且notifyAll()

JDK1.5中提供了多线程升级解决方案，将同步Synchronized替换成现实Lock操作

将Object中的wait,notify,notifyALL替换了condition对象
该对象可以Lock锁进行获取  

该示例中实现了本方只唤醒对方操作

注意有了lock必须finally中unlock，释放锁的操作一定要执行
*/
=========================================================
停止线程
===========================================================
stop方法过时，用run方法结束
只要控制住循环，就可以子线程中的让run方法里的循环结束，也就是线程结束
特殊情况：
当线程处于冻结状态，就不会读取到标记，那么线程就不会结束

当没有指定的方式让冻结的线程恢复到运行状态时，这时需要对冻结状态进行清除，强制让线程恢复到运行状态
这时可以操作标记让让线程结束

==========================================================
class StopThread implements Runnable
{
	private boolean flag = true;
	public void run()
	{	
		while(flag)
		{	
		/* try
			{
				wait();
			}
			catch(InterruptedException e)
			{
				System.out.println(Thread.currentThread.getName+"....Exception");
				flag = false;
			}
		
		*/
		
		
			System.out.println(Thread.currentThread().getName()+".....run");
		}
	}
	public void chageFlag()
	{
		flag = false;
	}
	
}
class StopThreadDemo
{
	public static void main(String[] args)
	{
		StopThread st = new StopThread();
		t1.setDaemon(true);
		t2.setDaemon(true);
		Thread t1 = new Thread(st);
		Thread t2 = new Thread(st);
		t1.start();
		t2.start();
		int num = 0;
		while(true)
		{
			if (num++ == 60)
			{
				st.changeFlag();
				break;
			}
			System.out.println(Thread.currentThread().getName()+".......run");
		}
	}
}
===================================================================================================
setDaemon(true);将该线程变为后台线程（守护线程），在线程开启前使用
join()方法:
当A线程执行到了B线程.join()方法时，A就会等待，等B线程都执行完A才会执行
join()可以用于临时加入线程

线程优先级1-10，通过方法setPriority()来调整


=====================================================================================================
class StopThread implements Runnable
{
	private boolean flag = true;
	public void run()
	{	
		while(flag)
		{	
		System.out.println(Thread.currentThread().getName()+".....run");
		//Thread.yield();临时释放该线程执行权，可以稍微减缓该线程的出现频率，使其不会连续获得执行权
		}
	}
	public void chageFlag()
	{
		flag = false;
	}
	
}
class StopThreadDemo
{
	public static void main(String[] args)
	{
		StopThread st = new StopThread();
		t1.setDaemon(true);
		t2.setDaemon(true);
		// t1.setPriority(Thread.MAX_PRIORITY);设置t1线程优先级最高
		Thread t1 = new Thread(st);
		Thread t2 = new Thread(st);
		t1.start();
		t2.start();
		int num = 0;
		while(true)
		{
			if (num++ == 60)
			{
				break;
			}
			System.out.println(Thread.currentThread().getName()+".......run");
		}
	}
}
=========================================================
当某些代码需要同时被执行时，可以用多线程执行，可以用匿名类完成，使代码更简洁
=================================
class ThreadTest
{
	public static void main(String[] args)
	{
		new Thread()
		{
			public void run()
			{
				for (int i = 0;i<100;i++)
				{
					System.out.prinln(Thread.currentThread().getName()+"....."+x);
				}
			}
		}.start();
		
		for (int i = 0;i<100;i++)
			{
				System.out.prinln(Thread.currentThread().getName()+"....."+x);
			}
		Runnable r = new Runnable()
		{
			public void run()
			{
				for (int i = 0;i<100;i++)
				{
					System.out.prinln(Thread.currentThread().getName()+"....."+x);
				}
			}
		};
			new Thread(r).start();
	}
}
=========================================================================================================
字符串一旦被初始化就不可以被改变
=====================================================================================================
class StringDemo
{
	public static void main(String [] args)
	{
		String s1 = "abc";   //   这句是定义一个String变量s，jvm会先去常量字符串池中找有没有”abc”，有的话就把s指向”abc”，没有就会先在池中创建一个，再让s指向”abc”。 
		s1 = "kk";           //   s1指向kk对象，abc对象依旧存在于内存中
		String s2 = new String("abc");// 这句是先定义一个String变量s，然后在内存中分配新的空间”abc”再让s指向这个内存地址
		String s3 = "abc";
		String s4 = new String("abc");
		/*
		s1和s2有什么区别？
		前者是java中标准的对象创建方式，其创建的对象将直接放置到堆中，每调用一次就会在堆上面创建一个新的对象；
		后者则会在栈中创建一个对象引用变量str，然后查看字符串池中是否存在”XXX”，如果没有，则将”XXX”存放字符串池，并令引用变量str指向它；
		如果已经有”XXX”，则直接令str指向它。这样充分利用了栈的数据共享优点，当然也可能是一个陷阱，对象很有可能没有创建，只不过指向一个先前已经创建的对象；而new()方法则能保证每次都指向新创建象。 
		*/
		//System.out.print(s1 == s2) 为假，s1和s2指向不同对象，地址不一样
		//System.out.print(s1 == s3) 为真，s1和s3指向的是字符串池中的同一个对象
		//System.out.print(s1.equals(s2))为真，String类中复写了Object类中的equals方法，该方法用于判断字符串是否相同
		//System.out.println(str2 == str4);
		
	}
}
==============================================================================================
String类适用于描述字符串事物
该类中提供了多个方法对字符串进行操作
常见的操作有哪些?

1获取
1.1获取字符串长度
int length();

1.2查找某个位置上的字符
char charAt(int index)

1.3获取ch字符在字符串中第一次出现的位置
int indexOf(int ch); 没找到返回-1
int indexOf(int ch,int fromIndex);从fromIndex位置开始查找，重载了indexOf方法
int lastindexOf(int cha) 反向索引ch字符第一次出现的位置(从后往前找)

获取str一字符串在字符串中的位置
int indexOf(String str);
int indexOf(String str,int fromIndex);从fromIndex位置开始查找，重载了indexOf方法

2判断
2.1字符串中是否包含某一个子串
boolean contains(str);
		indexOf(str)；也可以用，通过返回值是-1则不包含，否则包含。该方法既可以判断又可以获取出现的位置

2.2字符串中是否有内容
boolean isEmpty(str);//判断长度是否为0

2.3字符串是否以指定内容开头
boolean startsWith(str)；

2.4字符串是否以指定内容结尾
boolean endsWith(str);

2.5忽略大小写比较
boolean equalsIgnoreCase();

3转换

3.1将字符数组转换成字符串
构造函数：String(char[])
		  String(char[],offset,count) //offset是起始角标位，count是个数
char [] arr = {'a','b','c','d','e','f'};
String s = new String (arr);		  
		 
静态方法：static String copyValueOf(char[]);
		  static String copyValueOf(char[],offset.count);
		  static String valueOf(char[]);
3.2将字符串转换成字符数组
		  char[] tocharArray()
		  
3.3将字节数组转换成字符串
          String(byte[])
		  String(byte[],offset,count) //offset是起始角标位，count是个数
		  
3.4将字符串转换成字节数组
          byte[] getBytes()//字符串和字节数组在转换过程中是可以指定编码表的
		  
3.5将基本数据类型转换成字符串
static String valueOf(int)
static String valueOf(double)
3+""//String.valueOf(3);

4.替换
	String replace(oldchar,newchar )//replace返回的是一个新字符串，如果要替换的字符不存在，返回的还是原串
	replace(oldstring,newstring) //替换字符串中的某一小串
	
5.切割
String[] split(regex);以regex为分割标志,返回的是一个字符串数组！

6.子串
获取字符串中的一部分
String substring(begin)
String substring(begin,end)//包含begin角标位，不包含end角标位

7.转换，去除空格，比较
7.1 将字符串转成大写或小写
String toUpperCase()
String tolowerCase()

7.2将字符串两端的多个空格去除
String trim()

7.3对两个字符串进行自然顺序的比较
int compareTo(string) 
String s1 = "abc";
String s2 = "acc";
s1.compareTo(s2); //正数表示s1>s2 0表示相等，负数表示小于
java中从头到尾 一般含头不含尾，尾巴是.length
===========================================================
StringBuffer是字符串缓冲区	
1.是一个容器，而且长度是可变化的
2.可以直接操作多个数据类型
3.最终会通过toString()方法变成字符串
1.存储
StringBuffer append():将指定数据作为参数添加到已有数据结尾处 append内可以是int float boolean
StringBuffer insert(index,数据)：将数据插在index位上

2.删除
StringBuffer delete(int start,int end)()删除缓冲区中的数据包含start,不包含end
StringBuffer deletecharAt(int index)删除指定位置的数据

3.查找获取
char charAt(int index)
int indexOf(String str)
int lastIndexOf(String str)
int length()
String substring(int start,int end)

4.修改
StringBuffer replace(int start,int end,String str)包含start不包含end的部分用字符串str替换掉
void setChatAt(int index,char ch) 

5.翻转
StringBuffer reverse()

6将缓冲区中的指定数据存储到指定字符数组中
void getChars(int src begin,int src end ,char[] dst,int dstBegin)

JDK1.5之后出现StringBulider
StringBuffer是线程同步
StringBuilder是线程不同步
多线程用StringBuffer,单线程用StringBuilder
以后开发建议使用StringBuilder

JDK升级三个因素：
提高效率
简化书写
提高安全性
=======================================================================
基本数据类型对象包装类
int Integer
long Long
float Float
double Double
boolean Boolean
char Charcter
基本数据类型对象包装类的最常见作用就是用于基本数据类型和字符串之间做转换

基本数据类型转成字符串

基本数据类型+“”

基本数据类型.toString(基本数据类型值)

如：Integer.toString(34);//将34整数变成“34”

字符串转成基本数据类型
xxx a = Xxx.parseXxx(String);
int a = Integer.parseInt("123");//必须传入数字格式的字符串,静态调用方式
double a = Double.parseDouble("123.45")
boolean a = Boolean.parseBoolean("true")
Integer i = new Integer("123");
int num = i.intValue();//动态调用方式

十进制转换成其他进制
toBinaryString(String);
toHexString(String);
toOctalString(String);

其他进制转换成十进制
parseInt(String s,int radix) radix是“几进制”

JDK1.5版本之后出现的新特性
Integer i = new Integer(4);
Integer x = 4;//1.5版本之后可以这么写，x是引用数据类型，4是对象 自动装箱 //Integer x = null
x = x /* x.intValue() */+ 2;//进行了自动拆箱，变成了int类型和2进行加法运算，

Integer m = 128;
Integer n = 128;
(m == n)为false
Integer a = 127;
Integer b = 127;
(a == b)为true

因为当数值在byte范围内时，对于新特性，如果该数值已经存在则不会再开辟新的空间（byte范围：-128~127）
======================================================================================================
集合类
Colletion(接口)

子接口 List 包含类：ArrayList LinkedList Vector

ArrayList：底层使用的是数组数据结构，特点查询速度快，但是增删慢，线程不同步，相比Vector效率更高
		   初始容量为10，当元素个数超过10时，新建一个50%延长的数组，把原数据copy到新数组中，比Vector更节省内存空间
			
LinkedList：底层使用链表数据结构，特点增删速度很快，查询稍慢
            初始容量为10，当元素个数超过10时，新建一个100%延长的数组，把原数据copy到新数组中

Vector: 底层使用数组数据结构，线程同步
		枚举是是Vector的特有取出方法，Vector和Iterator方法实现功能相同
		Enumeration en = v.elements(); 
		en.hasMoreElements 与 it.hasNext类似

子接口 Set  包含类：Hashset TreeSet

为什么会出现这么多的容器
因为每个容器对数据的存储方式都不同，这种存储方式称为数据结构
/*
add方法的参数类型是obj，以便于接受任意类型对象
集合中存储的是对象的引用（亦可称之为该对象在内存中的地址）
*/
import java.util.*;
class ColletionDemo
{
	public static void main(String[] args)
	{
		ArrayList al_1 = new ArrayList();
		
		//增加元素
		al_1.add("java01")；
		al_1.add("java02")；
		al_1.add("java03")；
		al_2.add("java04")；
		al_2.add("java02")；
		al_2.add("java03")；

		
		//获取个数，集合长度
		System.out.println(al.size());
		
		//删除元素
		al.remove("java01");
		al.claer()//清空集合
		
		//判断元素
		System.out.println(al.contains("java03"));
		System.out.println(al.isEmpty());
		
		//取交集
		al_1.retainALL(al_2);
		/保留al_1中与al_2有交集的部分
		
		//迭代器
		Iterator it = al.iterator();
		while(it.hasNext()) //如果仍有元素可以迭代，返回true
			System.out.println(it.next()); //返回迭代的下一个元素
			
		for(Iterator it = al.iterator();it.hasNext();)//for循环实现方式，更节省内存空间，建立完it对象后即释放
			System.out.println(it.next());
		
		//什么是迭代器：其实就是取出元素的方式
		/*
			集合中的内容需要取出，把取出方式定义在集合内部，
			这样取出方式就可以直接访问集合内容的元素，取出方式被定义成了内部类
			
			而每一个容器的数据结构不同，取出的动作细节不一样，但都有共性内容：
			判断和取出，将共性抽取
			
			这些内部类都符合一个规则，该规则是Iterator，
			如何获取集合的取出对象呢？
			集合通过对外提供的itreator()方法 
		*/
	}
}
======================================================================
Colletion
	|--List:元素有序可以重复,该集合体系有索引
	|--Set：元素无序，不可重复
List:
	特有方法，凡是可以操作角标的方法都是该体系的特有方法
	
增：add(index,element)
	addAll(index,Colletion)

删：remove(index)

改：set(index,element)

查：get(index)
	subList(from,to)(包含头不包含尾)
	listIterator()

列表迭代器：
在迭代过程中（在遍历过程中）准备删除或添加元素
ListIterator是Iterator的子接口
在迭代时不可以不可以通过集合对象的方法操作集合中的元素，会发生ConcurrentModificationException
Iterator方法只能对元素进行判断，取出，删除
想要进行添加或修改，需用List集合的ListIterator方法进行获取

ListIterator li = al.listiterator();
		while(it.hasNext()) //如果仍有元素可以迭代，返回true
		{
			Object obj = li.next();
			if (obj.equals("java 02"))
				{
					li.add("java 002");
					//li.set("java 007");
				}
		}
			System.out.println(it.next()); //返回迭代的下一个元素
		
======================================================================================================================
linkedList
==================================================================================================================
import java.util.*;
/*
LinkedList特有方法：
addFirst()
addLast()

getFirst()//能够获取元素，但不删除，集合为空时会抛异常
getLast()


removeFirst()//也能够获取元素，但是元素被删除，集合为空时会抛异常
removeLast() 


JDK1.6后用替代方法

offerFirst()
offerLast()

peekFirst()//能够获取元素，但不删除,集合中没有元素则返回null
peekLast()

pollFirst()//能够获取元素，并且删除,集合中没有元素则返回null
pollLast()

*/
LinkedList link = new LinkedList();
link.add("java01");
link.add("java02");
link.add("java03");			
=================================================================================================================
练习：1.使用LinkedList实现栈和队列数据结构
	  2.ArrayList数组去重（5种方法）
List集合判断元素是否相同，底层的实现的是equals方法
contains(Object obj) remove(Object obj)判断时，底层用的都是equals方法
==================================================================
/*
	复写equals方法
*/
import java.util.*;
class Person
{
	private String name;
	private int age;
	Person(String name,int age)
	{
		this.name = name ;
		this.age = age ;
	}
	public String getName()
	{
		return name;
	}
	public int age()
	{
		return age;
	}
	public boolean equals(Object obj)
	{
		if (!(obj instanceof Person))
			return false
		Person p = (Person)obj;
		return this.name.equals(p.name)&&this.age == p.age;
	}	
}
class ArrayListTest
{	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
	public static void main(String[] args)
	{
		ArrayList al = new ArrayList();
		al.add(new Person("lisi01",30));
		al.add(new Person("lisi02",31));
		al.add(new Person("lisi03",30));
		al.add(new Person("lisi01",30));
		/*
		al.add("lisi01");
		al.add("lisi02");
		al.add("lisi03");
		al.add("lisi01");
		如果是这种情况的话，往ArrayList里存放的是字符串，因为有字符串池的存在，相同内容的字符串指向的是字符串池中的同一字符串，在内存中的地址是一样的
		这时用ArrayList中的contains方法不会影响判断结果
		*/
		al = singleElement(al);
		Iterator it = al.iterator();
		while(it.hasNext())
		{
			Person p = (Person)it.next;  //al.add(object) 也就是说往al里存的是Object类，这里想要用子类对象的特有方法需要把父类引用进行强转
			sop(p.getName()+"....."p.getAge()) 
			//sop(it.next().getName()+"..."+it.next.getAge());会编译失败，因为it.next()返回的是object类的对象
		}
	}
	public static singleElement(ArrayList al)
	{
		//定义一个临时容器
		ArrayList newAl = new ArrayList();
		
		Iterator it = al.iterator();
		while(it.hasNext())
		{
			Object obj = it.next();
			
			/*  contains的源码实现是利用了obj.equals()方法和ArrayList里的每个元素进行比较，
				在本例中 通过把指向子类对象的父类引用obj强制转换为子类Person对象，
				并在子类Person中复写了Object类中的equals()方法实现了特有内容的对比
			*/
			if(!newAl.contains(obj)) 
				newAl.add(obj);
		}
		return newAl;
	}
}
=====================================================================================================
频繁增删 LinkedList
有增删，有查改 用ArrayList
====================================================================================================
----Set:元素是无序（存入和取出顺序不一定一致），元素不可以重复
	|--HashSet:底层结构是哈希表
	HashSet是如何保证元素的唯一性呢？
	通过元素的两个方法，hashCode和equals方法
	如果元素的hashCode相同，才会判断equals是否为true
	如果元素的hashCode不同，不会进行判断
	对于判断元素是否存在以及删除等操作，底层依赖的是判断元素的hashCode()方法返回的值是否相同 和 equals方法
	P.s hashSet取出元素只能用迭代器方法
	|--TreeSet:
Set集合的功能和Colletion功能是一致，没有自己特有的方法
============================================================================================================
import java.util.*;
class Person
{
	private String name;
	private int age;
	Person(String name,int age)
	{
		this.name = name ;
		this.age = age ;
	}
	public String getName()
	{
		return name;
	}
	public int age()
	{
		return age;
	}
	public boolean equals(Object obj)
	{
		if (!(obj instanceof Person))
			return false
		Person p = (Person)obj;
		return this.name.equals(p.name)&&this.age == p.age;
	}	
	public int hashCode()
	{
		return name.hashCode()+age*20;//age*20是为了避免姓名不同，年龄相同 在进行hashCode计算时，刚好字符串返回的hash值相同的这种情况
	}
}
class hashSetDemo{
public static void main(String[] args)
	{
		hashSet hs = new hashSet();
		hs.add(new Person("lisi01",30));
		hs.add(new Person("lisi02",31));
		hs.add(new Person("lisi03",30));
		hs.add(new Person("lisi01",30));
		Iterator it = hs.iterator();
		while(it.hasNext())
		{
			Person p = (Person)it.next;  //al.add(object) 也就是说往al里存的是Object类，这里想要用子类对象的特有方法需要把父类引用进行强转
			sop(p.getName()+"....."p.getAge()) 
			//sop(it.next().getName()+"..."+it.next.getAge());会编译失败，因为it.next()返回的是object类的对象
		}
	}
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
======================================================================================================================
----Set:元素是无序（存入和取出顺序不一定一致），元素不可以重复
	|--HashSet:底层数据结构是哈希表，线程是非同步的
			   保证元素的唯一性的原理：判断元素的hashCode()是否相同，如果相同还会继续判断元素的equals方法是否为true
	
	|--TreeSet:可以对set集合中的元素进行排序
			   记住，排序时，当主要条件相同时，一定要记得比较一下次要条件
			   底层数据结构是二叉树，保证元素的唯一性的依据是compareTo()方法return的值——0表示相同，1 -1表示不同
			   
			   TreeSet排序的第一种方式是：让元素自身具备比较性，元素需要implements Comparable接口，复写compareTo()方法
			   这种方式称为元素的自然顺序，或者叫做默认顺序
			   
			   TreeSet排序的第二种方式是：当元素自身不具备比较性，或者具备的比较性不是所需要的
			   这时就需要让集合自身具备比较性
			   在集合初始化时就具备比较性
			   
			   P.s当两种排序都具备时，以比较器为主
===========================================================================================================================
//按年龄大小对Person对象进行排序
import java.util.*;
class Person implements Comparable//该接口强制让学生具备比较性
{
	private String name;
	private int age;
	Person(String name,int age)
	{
		this.name = name ;
		this.age = age ;
	}
	public String getName()
	{
		return name;
	}
	public int age()
	{
		return age;
	}
	public boolean equals(Object obj)
	{
		if (!(obj instanceof Person))
			return false;
		Person p = (Person)obj;
		return this.name.equals(p.name)&&this.age == p.age;
	}	
	public int hashCode()
	{
		return name.hashCode()+age*20;//age*20是为了避免姓名不同，年龄相同 在进行hashCode计算时，刚好字符串返回的hash值相同的这种情况
	}
	public int compareTo(Object obj)
	{
		if (!(obj instanceof Person))
			throw new RuntimeException("不是学生对象");
		Person p = (Person)obj;
		if (this.age>s.age)
			return 1;
		if (this.age == s.age)
			return this.name.compareTo(s.name);
		return -1;
	}
}
class hashSetDemo{
public static void main(String[] args)
	{
		TreeSet ts = new TreeSet();
		ts.add(new Person("lisi01",30));
		ts.add(new Person("lisi02",31));
		ts.add(new Person("lisi03",30));
		ts.add(new Person("lisi01",30));
		Iterator it = hs.iterator();
		while(it.hasNext())
		{
			Person p = (Person)it.next;  //al.add(object) 也就是说往al里存的是Object类，这里想要用子类对象的特有方法需要把父类引用进行强转
			sop(p.getName()+"....."p.getAge()) ;
			//sop(it.next().getName()+"..."+it.next.getAge());会编译失败，因为it.next()返回的是object类的对象
		}
	}
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
=========================================================================================================================================
当元素自身不具备比较性，通过比较器这种方式，将比较器作为参数传递给TreeSet集合的构造函数
===================================================================================================================
/*
定义一个类，实现Comparator接口，复写compare()方法
让Person对象按姓名进行排序
*/
import java.util.*;
class Person implements Comparable//该接口强制让学生具备比较性
{
	private String name;
	private int age;
	Person(String name,int age)
	{
		this.name = name ;
		this.age = age ;
	}
	public String getName()
	{
		return name;
	}
	public int getAge()
	{
		return age;
	}
	public boolean equals(Object obj)
	{
		if (!(obj instanceof Person))
			return false;
		Person p = (Person)obj;
		return this.name.equals(p.name)&&this.age == p.age;
	}	
	public int hashCode()
	{
		return name.hashCode()+age*20;//age*20是为了避免姓名不同，年龄相同 在进行hashCode计算时，刚好字符串返回的hash值相同的这种情况
	}
	public int compareTo(Object obj)
	{
		if (!(obj instanceof Person))
			throw new RuntimeException("不是学生对象");
		Person p = (Person)obj;
		if (this.age>s.age)
			return 1;
		if (this.age == s.age)
			return this.name.compareTo(s.name);
		return -1;
	}
}
class TreeSet_Comparator_Demo
{
	public static void main(String[] args)
	{
		TreeSet ts = new TreeSet(new MyCompare());
		ts.add(new Person("lisi01",30));
		ts.add(new Person("lisi02",31));
		ts.add(new Person("lisi03",30));
		ts.add(new Person("lisi01",30));
		Iterator it = ts.iterator();
		while(it.hasNext())
		{
			Person p = (Person)it.next;  //al.add(object) 也就是说往al里存的是Object类，这里想要用子类对象的特有方法需要把父类引用进行强转
			sop(p.getName()+"....."p.getAge()) 
			//sop(it.next().getName()+"..."+it.next.getAge());会编译失败，因为it.next()返回的是object类的对象
		}
	}
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
class MyCompare implements Comparator
{
	public int compare(Object o1,Object o2)
	{
		Person s1 = (Person)o1;
		Person s2 = (Person)o1;
		int num = s1.getName().compareTo(s2.getName());
		if(num == 0)
			{	
				/*
				if(s1.getAge()>s2.getAge)
					return 1;
				if(s1.getAge() == s2.getAge)
					return 0;
				return -1;
				*/
				//return new Integer(s1.getAge().compareTo(new Integer(s2.getAge())));
				return s1.getAge()-s2.getAge();
			}
	}
}
======================================================================================================
集合框架：泛型概述
JDK1.5之后出现的新特性，用于解决安全问题

往ArrayList里存放的只能是String 类型的元素，如果不是，编译无法通过，
对ArrayList里存放的东西进行了客观的约束
ArrayList<String> al = new ArrayList<String>();

其实<>就是用来接收数据类型的
当使用集合时，将集合中要存储的数据类型作为参数传递到其中即可

注意hashSet中hashCode()方法里的equals方法一定要用强转，没法使用泛型
==========================================================================================
泛型类：
当类中要操作的引用数据类型不确定时，早期定义Object来完成扩展，现在定义泛型来完成扩展
class Student
{}
class Worker
{}
class Util<QQ>
{
	private QQ q;
	public void setObject(QQ q)
	{
		this.q = q;
		
	}
	public QQ getObject()
	{
		return q;
	}
}
class GenericDemo
{
	public static void main(String[] args)
	{
		Util<Worker>u = new Util<Worker>();
		u.setObject(new Worker());
		Worker w = u.getObject();
	}
}
============================================================================================
泛型类定义的泛型，在整个类中有效，如果被方法使用
那么泛型类对象明确要操作的具体类型后，所有要操作的类型就已经固定

为了让不同方法可以操作不同类型，而且类型还不确定
特殊之处：
静态方法不可以访问类上定义的泛型
如果静态方法操作的引用数据类型不确定，可以将泛型定义在静态方法上
====================================================================
class Demo<T>
{
	public  void show(T t)
	{
		System.out.println("show:"+t);
	}
	public <Q> void print(Q q)
	{
		System.out.println("print:"+t);
	}
}
class GenericDemo
{
	public static void main(String[] args)
	{
		Demo d = new Demo();
		d.show("hah");
		d.show(4);
		d.print("as")
	}
}
==========================================
泛型定义在接口上
=========================================
interface Inter<T>
{	
	void show(T t);
}
/*
class InterImpl implements Inter<String>
{
	public void show(String t)
	{
		System.out.println(t);
	}
}
*/
class InterImpl<T> implements Inter<T>
{
	public void show(T t)
	{
		System.out.println(t);
	}
}
class GenericDemo
{
	public static void main(String[] args)
	{
		InterImpl<Integer> i = new InterImpl<Integer>();
		i.show(4);
	}
} 
===================================================================
?通配符 也可以理解为占位符
? extends E:可以接受E类型或者E类型的子类
? super E :可以接受E类型或者E类型的父类
===============================================
class GenericDemo
{
	public static void main(String[] args)
	{
		ArrayList<String>a1 = new ArrayList<String>;
		a1.add("abc1");
		a1.add("abc2");
		a1.add("abc3");
		ArrayList<Integer>a2 = new ArrayList<Integer>;
		a2.add(1);
		a2.add(2);
		a2.add(3);
		printcoll();
	}
	public static void printcoll(ArrayList<?> al)//public static <T> void printcoll(ArrayList<T> al)
	{
		Iterator<?>it = al.iterator();//Iterator<T>it = al.iterator();
		while(it.hasNext())
			{
				System.out.println(it.next());// T t = it.next();Syetem.out.println(t);
			}
	}
}
======================================================================
/*泛型限定：? extends E:可以接受E类型或者E类型的子类,上限
			? super E :可以接受E类型或者E类型的父类，下限
*/
class Person
{
	private String name;
	Person(String name)
	{
		this.name = name;
	}
	public String getName()
	{
		return name;
	}
}
class Student extends Person
{
	Student(String name)
	{
		super(name);
	}
}
class GenericDemo
{
	public static void main(String[] args)
	{
		ArrayList<Person>a1 = new ArrayList<Person>;
		a1.add(new Person("abc1"));
		a1.add(new Person("abc2"));
		a1.add(new Person("abc3"));
		
		ArrayList<Student>a2 = new ArrayList<Student>;
		a2.add(new Student("abc11"));
		a2.add(new Student("abc12"));
		a2.add(new Student("abc13"));
		printcoll();
		
		printcoll(a1);
	}
	public static void printcoll(ArrayList<? extends Person> al)//public static <T> void printcoll(ArrayList<T> al)
	{
		Iterator<? extends Person>it = al.iterator();
			{
				System.out.println(it.next().getName());
			}
	}
}
=================================================================================================================
Map集合：
该集合存储键值对，一对一对往里存，而且要保证键值的唯一性
Map<K,V > K V指的是类
1.增
put(K key,V value); 添加元素时，如果出现添加相同的键那么后添加的值会覆盖原有键对应值，并put方法返回被覆盖的那个值
putaLL(Map<? extends K, ? extends V >m);
2.删
claer()
3.判断
boolean containsKey(Object value)
boolean containsValue(Object key)
isEmpty()
remove(Object Key)
4.获取
get(Object key) //通过get方法返回值判断一个键是否存在，通过返回null或者数字1 来判断
map.size() //返回map的长度
map.values() //返回map中所有的value
keySet()

entrySet()
keySet()

Map-------
	|------Hashtabale:底层是哈希表数据结构，不可存入null值，null键，该集合线程同步
	|------HashMap：  底层是哈希表数据结构，可存入null值，null键，该集合是不同步
	|------TreeMap：  底层是二叉树数据结构，线程不同步，可用于给Map集合中的键进行排序
其实Set底层用了Map集合
	
keySet()：将map中所有的键存入到Set集合中，因为set具备迭代器，以迭代器的方法取出所有的键，再根据get方法获取每一个键对应的值
Map<String,String> map = new HashMap<String,String>();
map.put("01","zhangsan");
map.put("02","zhangsan2");
map.put("03","zhangsan3");
Set<String> keySet = map.keySet();
Iterator<String> it = keySet.iterator();
while(it.hasNext())
{
	String key = it.next();
	String value = map.get(key);
	System,out.println("key:"+key+"value"+value);
}
	
===========================================================================
entrySet():
Set <Map.Entry<k,v>> entrySet:将map集合中的映射关系存入到set集合中
							  而这个关系的数据类型就是Map.Entry
							  
Map<String,String> map = new HashMap<String,String>();
map.put("01","zhangsan");
map.put("02","zhangsan2");
map.put("03","zhangsan3");
Set<Map.Entry<String,String>> entrySet = map.entrySet();

Iterator<Map.Entry<String,String>> it = entrySet.iterator();

while(it.hasNext())
{
	Map.Entry<String,String> me = it.next();
	String key = me.getKey();
	String value = me.getValue();
	System.out.println(key+":"+value);
	
}
===============================================================================================================
新建一个学生类，要复写hashCode()方法,equals方法，并且让其具备可比性（implements comparable），以保证存入hashSet，TreeSet,hashMap,TreeMap容器时无误
=================================================================================================================
/*
获取一个字符串中字母出现次数，“asasd”
希望打印结果：a(2) s(2)

字母和次数之间有映射关系，考虑使用map集合，map集合中存放的就是映射关系
*/
import java.util.*;
class MapTest
{
	public static void main(String[] args)
	{
		String str = "asaddasd";
		System.out.prinln(charCount(str));
	}
	public static String charCount(String str)//工具类用静态方法较好，外部类可以直接通过类名调用
	{
		char[] chs = str.tocharArray();
		TreeMap<Charcter,Integer> tm = new TreeMap<Charcter,Integer>();
		for(int i = 0;i<str.length;i++)
			{	int count = 0;
				Integer value = tm.get(chs[i]);
				if(tm.get(value != null)
					count = value;
				count++;
				tm.put(chs[i],count);
			}
			StringBuilder sb = new StringBuilder();
			
			Set<Map.Entry<String,Integer>> entrySet = tm.entrySet();

			Iterator<Map.Entry<String,Ingeger>> it = entrySet.iterator();

		while(it.hasNext())
		{
			Map.Entry<String,Integer> me = it.next();
			String key = me.getKey();
			Integer value = me.getValue();
			sb.append(key+"("+value+")");
	
		}
		return sb.toString();
	}
}
=========================================================================================
map扩展知识：
============================================================
集合框架工具类：

Colletions.sort(List list)
Colletion.sort(List list,comparator c)//按照comparator的规则对List进行比较
Colletions.max(List list)
Colletions.max(List list,comparator c)
Colletions.binarySearch(List list)//有则返回角标，没有则返回-(插入点-1)
Colletions.fill(List list , Object obj) 将list集合中的所有元素替换成指定元素
Colletions.replaceAll(List list,Object obj1,Object obj2)将list集合中所有的obj1元素替换成obj2元素
Colletion.reverseOrder() 返回的是一个按照自然顺序逆序的比较器，也可以将现有的比较器变成逆序并返回
Colletions.synchronizedList(List list)将list变成线程同步即多线程安全的
Colletions.swap(List,int index1,int index2)交换 index1和index2角标位的元素
Colletions.shuffle(List,list)将list集合按随机顺序重新排放
Arrays.asList(arr[])  把数组变成集合，用集合的思想和方法操作数组中的元素，将数组变成集合，不可以使用增删方法，因为数组的长度是固定的
注意： 如果数组中的元素都是对象，那么变成集合时，数组中的元素直接变成集合中的元素
	   如果数组中的元素是基本数据类型，那么变成集合时，会将该数组本身作为集合中元素的存在
将集合转数组：
ArrayList<String> a1 = new ArrayList<String>();
a1.add("abc1");
a1.add("abc2");
a1.add("abc3");
String[] arr = a1.toArray(new String[a1.size()]);
//.toArray(<T[] a>) 返回T类型的数组
//当指定类型的数组长度小于集合的size,那么该方法内部会创建一个长度为集合的size的数组
//当指定类型的数组长度大于集合的size,那么就不会新建数组，而是使用传进的这个数组

为什么要将集合变成数组？
为了限定对元素的操作
=====================================================================
增强for循环
for(数据类型 变量名：被遍历的集合或者元素)
{}

ArrayList<String> a1 = new ArrayList<String>();
al.add("abc1");
al.add("abc2");
al.add("abc3");

for(String s : al)
{}

增强for循环只能获取集合元素，但不能对集合元素进行操作

迭代器除了遍历，还可以进行remove集合中元素的动作，如果使用ListIterator还可以在遍历时对集合进行增删改查

传统for循环和高级for循环
高级for循环必须有一个遍历的目标 
=======================================================
JDK1.5之后可变参数
public static void show (int... arr){
}
其实就是public static void show(int[] arr){
}的简写形式瞒不过不需要每一次都建立一个数组对象，只要将要操作的元素作为参数传递，隐式的将这些参数封装成了数组

使用时注意：可变参数一定要定义在参数列表的最后一个
================================================================
静态导入：
import static pack.类名* 导入该包中某个类里所有的静态成员

System类中的方法都是静态的

Runtime对象
该类并没有提供构造函数，不可以new对象，会直接想到该类中的方法都是静态的 
发现该类中还有非静态的方法
说明该类肯定会提供了方法获取本类对象，而且该方法是静态的，返回值类型是本类类型
使用了单例设计模式：保证了对象的唯一性
该方法是Static Runtime getRuntime()

Runtime r = Runtime.getRuntime();
Process p = r.exec("notepad.exe");
Thread.sleep(4000);//让该线程休眠4秒
p.destroy();//杀死该进程

Date类//text包里
Date d = new Date();
//将模式封装到SimpleDateFormat中
SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日")；
//调用format方法，让模式格式化指定Date对象
sdf.format(d);

Calendar类//util包里
Calendar c = Calendar.getInstance()
c.get(Calendar.YEAR)
c.get(Calendar.MONTH)
c.get(Calendar.DEY_OF_MONTH)
c.get(Calendar.DEY_OF_WEEK
c.set(yyyy,m,dd)将日历的指定字段设置为给定的值
c.add(Calendar.YEAR,4)当前年份+4

Math类 lang包
double d = Math.ceil(a) //大于指定数据的最小整数
double d1 = Math.floor(a) //小于指定数据的最大整数
long l = Math.round(a) //四舍五入
double d2 = Math.pow(a,b) a^b
int d = (int)(Math.random()*10+1)  //产生一个1-10之间的随机数

util包里也有随机数生成器
Random r = new Random(); 
r.nextInt(10)+1;返回1到10的随机数

====================================================================================
IO流
字节流
InputStream OutputStream

字符流
Reader Writer

需求：在硬盘上创建一个文件，并写入文字数据
import java.io.*;
class FileWriterDemo
{
	public static void main(String [] args) throws IOException
	{	//创建一个FileWriter对象，该对象一旦被初始化就必须要明确备操作的文件
		//而且该文件会被创建到指定目录下，如果该目录下已有同名文件，则会被覆盖
		
		
		FileWriter fw = new FileWriter("demo.txt");
		//调用write方法，将数据写入到流中
		fw.write("abcde");
		//刷新该流对象中缓冲中的数据，将数据刷到目的地
		fw.flush();
		//fw.close();方法关闭流资源，关闭前会刷新一次内部缓冲中的数据，将数据刷到目的地
		//flush刷新后可以继续使用，close刷新后会关闭流
	}
	
}
/////////////////////////////////////////////////////////////////////////////////////
IO异常处理方式
import java.io.*;
class FileWriterDemo
{
	public static void main(String [] args) 
	{	
		FileWriter fw = null；
		
		try
		{
			fw = new FileWriter("demo.txt");
			//fw = new FileWriter("demo.txt",true);加上true这个标志位表示不覆盖原文件，在原文件的后面继续写
			fw.write("abc/r/nde");//在windows系统中用/r/n两个转义字符表示换行
		}
		catch(IOException e)
		{
			System.out.println(e.toString());
		}
		finally
		{
			try
			{
				if (fw != null)
					fw.close();
			}
			catch(IOException e)
			{	
				Syste,.out.println(e.toString());
			}
		}
	}
}
//int ch = fw.read()一次读一个字符，会自动往下读读完一个文件时会返回-1
//返回的一个整数，可以用(char)ch将该整数还原会字符
//第二种read方法返回读到的字符个数
char[] buf = new char[1024];
int num = fr.read(buf);//返回读到的字符个数，并将读到的内容存在指定的buf字符数组中
//若文件中的字符数比buf多，一次那就只能读buf数组大小的个数，后面继续读到的如果仍放在buf会把原来存放的内容从头覆盖
//buf的大小一般都定义1024的整数倍，一个字符占两个字节
char[] buf = new char[1024];
int num = 0;
while(num = fr.read(buf)!= -1)
{
	System.out.print(new String (buf,0,num)); 
}


需求：拷贝文件

import java.io.*;
class CopyDemo
{
	public static void main(String [] args) 
	{	
		copy_2();
	}
	public static void copy_2()
	{
			FileWriter fw = null；
			FileReader fr - null;
		
		try
		{
			fw = new FileWriter("des");
			fr = new FileReader("source");
			char buf = new char[1024];
			int num = 0;
			while(num = fr.read(buf)!= -1)
			{
				fw.write(buf,0,num);
			}
		}
		catch(IOException e)
		{
			throw new RuntimeException
		}
		finally
		{
			try
			{
				if (fr != null)
					fr.close();
			}
			catch(IOException e)
			{	
				Syste,.out.println(e.toString());
			}
			finally{
				try
			{
				if (fw != null)
					fw.close();
			}
			catch(IOException e)
			{	
				Syste,.out.println(e.toString());
			}
			}
		}
	}
}
