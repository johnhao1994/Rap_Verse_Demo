异常：
是对问题的描述，将问题进行对象的封装
-----------------------------------------------------------
异常体系：
		Throwable
			--Error
			--Exception
				--RuntimeException

异常体系的特点：异常体系中的所有类及建立的对象都具备可抛性
可以被throw和throws关键字操作
throw定义在函数内
throws定义在函数上，可抛出多个异常，用逗号隔开


当函数内容有throw抛出异常对象，并未进行catch处理，必须要在函数上声明(即有throws)，否则编译失败
注意，RuntimeException除外，也就是函数如果抛出的是RuntimeException异常，函数上可以不用声明
-------------------------------------------------------------------------------------------------
如果函数声明了异常，调用者需要处理（try或者throws）

异常有两种：
			编译时被检测异常
				该异常在编译时，如果没有处理，编译失败
				该异常被表示，代表者可以被处理
			运行时异常（编译时不检测）
				在编译时不需要处理，编译不检查
				该异常的发生建议不处理，让程序停止，需要对代码进行修正
-------------------------------------------------------------------------------------------------------
处理异常的方式：
1.
try                   
{
}
catch()
{
}
2.
try
{
}
finally
{
}
3.
try
{
}
catch
{
}
				
注意：
1.对于处理异常代码的finally是一定会执行的，通常在里面定义的是关闭资源代码，因为资源必须释放
2.finally只有一种情况不会执行，当执行到System.exit(0);表示虚拟机直接结束，就不会执行finally中的代码，
3.throw在函数中单独存在时，下面不能放语句像return一样，不然无法通过编译
----------------------------------------------------------------------------------
自定义异常
	定义类一般继承Exception或者RuntimeException
	1.为了让该自定义类具有可抛性
	2.让该类具备操作异常的共性方法
	
	当要自定义异常的信息时，可以使用父类已经定义好的功能，异常信息传递给父类的构造函数
	
	class Myexception extends Exception
	{
		Myexception(String message)
		{
			super(message);
		}
	}
	
自定义异常是按照java的面向对象思想，将程序中的特有问题进行封装
----------------------------------------------------------------------------------------------
异常的好处：
1.将问题进行封装
2.将正常流程代码和问题处理代码相分离，方便阅读

---------------------------------------------------------------------------------------
异常处理原则：
	1.调用到抛出异常的功能时，抛出几个，就catch几个
	2.多个catch，父类Exception的catch放到最下面
	3.catch内要定义针对性的处理方式，不要定义简单的输出语句，可以输出到异常日志

	当捕获到的异常，本功能处理不了时，可以继续在catch中抛出
	try
	{
		throw new AException();
	}
	catch (AException e)
	{
		throw e;
	}
	如果该异常处理不了，但并不属于该功能出现的异常，可以将异常转换后在抛出和功能相关的异常
	
	或者异常可以处理，需要将异常产生的和本功能相关的问题提供出去，让调用者知道，并处理
		try
	{
		throw new AException();
	}
	catch (AException e)
	{
		throw new Bexception;
	}	
------------------------------------------------------------------------------------------------
异常的注意事项：
在子父类覆盖时：
	1.子类抛出的异常必须是父类的异常的子类或者子集
	2.如果父类或者接口没有异常抛出，子类覆盖出现异常只能try不能抛
-----------------------------------------------------------------------------------------------------
重要例子1：

1.老师用电脑上课
分析：
创建老师对象，校长调用老师的讲课方法-->老师对象调用电脑的运行方法-->

-->1.如果电脑出现蓝屏异常则重启

-->2.如果电脑出现冒烟异常,老师处理不了，调用布置练习方法并抛出课时无法按时完成异常

-->校长catch到老师的课时无法按时完成的异常，进行换老师操作

class BluescreenException extends Exception
{
	BluescreenException(String message)
	{
		super(message);
	}
}

class SmoingException extends Exception
{	
	SmoingException(String message)
	{
		super(message);
	}
}

class NoPlanException extends Exception
{
	NoPlanException(String msg)
	{
		super(msg);
	}
}

class Computer
{	private int state = 1;
	public void run() throws BluescreenException,SmoingException
	{	if(state == 2)
		{
			throw new BluescreenException("蓝屏了");
		}
		if(state == 3)
		{
			throw new SmoingException("冒烟了")；
		}
		System.out.println("电脑运行")；
	}
	public void restart()
	{	
		state = 1;
		System.out.println("电脑重启")；
	}
}

class Teacher
{
	private String name;
	Teacher(String name)
	{	
		this.name = name;
		cmpt = new Computer();
	}
	public void prelect() throws NoPlanException
	{	
		try
		{
			cmpt.run();
		}
		catch(BluescreenException e)
		{
			cmpt.restart()
		}
		catch(SmoingException e)
		{	
			test();
			throw new NoPlanException("课时无法继续"+e.getMessage());
		}
		System.out.println("开始讲课")；
	}
	public void test()
	{
		System.out.println("练习")；
	}
	
}

class ExceptionTest
{
	public static void main(String[] args)
	{
		Teacher t = new Teacher("毕老师")；
		try
		{
			t.prelect();
		}
		catch(NoPlanException e)
		{
			System.out.println(e.toString);
			System.out.println("换老师")；
		}
	}	
}
-------------------------------------------------------------------------------------------------------------
重要例子2：


如果出现非法数值，后面的运算与操作没有意义要让程序立即停掉，
interface Graph
{
	void getArea();
}

class illeagleException extends RuntimeException
{
	illeagleException(string message)
	{
		super(message);
	}
}
class Rec implements Graph
{
	private int len,wid;
	Rec(int len,int wid)
	{	if(len <= 0 || wid <= 0)
		{
			throw new illeagleException("出现非法值")；
		}
		this.len = len;
		this.wid = wid;
	}
	public void getArea()
	{
		System.out.println(len*wid);
	}
}

class Cicle implements Graph
{
	private int radius;
	public static final PI = 3.14;
	Circle(int radius)
	{	
		if (radius <= 0)
		{
			throw illeagleException("出现非法值")；
		}
		this.radius = radius;
		
	}
	public void getArea
	{
		System.out.println(radius*radius*PI)
	}
}
class ExceptionTest2
{
		public static void main(String[] args)
		{
				Rec r = new Rec(3,4);
				r.getArea();
		}
}

--------------------------------------------------------------------------------------------------------
                                       Java包的内容
------------------------------------------------------------------------------------------------------

总结：
一个.java中只能有一个puclic class

类名的全名是包名.类名（注意完整性）

pack包如果不在当前目录下，需要设置classpath，告诉jvm去哪里找指定的包


包与包之间进行访问，被访问的包中的类以及类中的成员需要public修饰

不同的包中的子类还可以直接访问父类中被protected权限修饰的成员,也就是说如果某个包中的类A用protected修饰，那么在其他包中的类如果不是A的子类则不能访问A类中的成员

包与包之间可以使用的权限只有两种，public  protected

			public		protected	default		private
同一个类中   √				√			√			√
同一个包中	 √				√			√			X
子类		 √				√
不同包中	 √				


为了简化类名的书写，使用一个关键字，import
import 包名.包名.????.*  表示将该包中的类全部导入，注意导入的仅是类 ，子包不会导入

建议不要写写通配符*

建议定义包名时不要重复，可以使用Url完成定义，Url是唯一的

-------------------------------------------------------------------------------------------------
                                       jar包
-------------------------------------------------------------------------------------------------






--------------------------------------------------------------------------------------------------
                                        线程
--------------------------------------------------------------------------------------------------
多线程同时执行，提高效率
创建多线程办法

1.继承Thread类，并覆盖run方法，run方法中存放多线程要执行的内容


class Test extends Thread
{
	Test(String name)
	{
		super(name);
	}

	public void run()
	{
		for(int x=0; x<60; x++)
		{
			System.out.println("test run"+ x);
		}
	}
}

class TestDemo
{
	public static void main(String [] args)
	{
		Test t1 = new Test();
		Test t2 = new Test();
		t1.start(); //子线程
		t2.start();  //子线程
		
		for (int x = 0; x<60; x++)    //主线程
		{
			System.out.println("main" + x);
		}

	}
}

线程运行状态：

             
                               阻塞状态（具备运行资格，但还有没执行权）
                                   ^						  ^	   
							      /                            \
								 /		                        \
                                /                                \
被创建——————————————————————>运行——————————————————————————————>冻结
          start()              |              sleep(time)
							   |			   wait()		(注意：wait 会将线程挂起，一直等待，而sleep时间到了就会醒来会进入阻塞或者运行状态)
	   	                       |              ————————————>
							   |			<————————————————
							   |				  notify()或者sleep时间到
							   |
							   |
							   |
							   |   stop()或者run方法结束
							   |
							   v
							  消亡 
							  
Thread类中的方法：
static Thread currentThread():获取当前线程对象
getName():获取线程名称

设置线程名称：setName或者构造函数
P.S 局部的变量在每个线程区域中都有独立的一份

2.创建线程的第二种方式：实现Runable接口

1.定义类实现Runable接口
2.覆盖Runable接口中的run方法
将线程要运行的代码存放在该run方法中

3.通过Thread类建立线程对象
4.将Runable接口的子类对象作为实际参数传递给Thread类的构造函数

5.调用Thread类的start方法开启线程并调用Runable接口子类的的run方法	

实现方式和继承方式有什么区别：
实现方式：避免了单继承的局限性
在定义线程时建议使用实现的方式

class Ticket implements Runnable
{
	private int ticket = 100;
	public void run()
	{
		while(true)
		{
			if (ticket > 0)
			{
				System.out.println(Thread.currentThread().getName() + ".....sale" + ticket--);
			}
		}
	}
}

class TestDemo
{
	public static void main(String [] args)
	{
		Ticket t = new Ticket();
		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);
		Thread t3 = new Thread(t);
		Thread t4 = new Thread(t);
		t1.start();
		t2.start();
		t3.start();
		t4.start();

	}
}
多线程带来的安全隐患：
	当多条语句在同一个线程共享数据时，一个线程对多条语句只执行了一部分还没有执行完时
	另一个线程参与进来执行，导致共享数据的错误 

解决办法：
		对多条操作共享数据的语句，只能让一个线程都执行完。在执行过程中别的线程不能参与执行
		
java中提供的解决办法：
同步代码块

synchronized(对象)
{
	需要被同步的代码
}
对象如同锁，持有锁的线程可以在同步中执行。
没有持有锁的线程即使获得cpu的执行权也进行不下去，因为没有锁

同步的前提：
必须要有两个或两个以上的线程
必须是多个线程使用同一个锁

好处：解决了多线程的安全问题
弊端：多个线程需要判断锁，较为消耗资源

也可以让函数有同步的特性，用关键字synchronized修饰函数，不过同步函数使用的锁是this

同步函数被静态修饰后，使用的锁是该方法所在类的字节码文件对象。类名.class 类型是Class

写一个延迟加载的单例设立模式 懒汉式
class Single
{
	private static Single s = null;
	private Single(){}
	public static Single getInstance()   //同步函数的方式：public static synchronized Single getInstance()   
	{
		if(s==null)
		{
			synchronized(Single.class)
			{
				if (s==null)
					s = new Single();
			}
		}
		return s;
	}
}

死锁问题：
同步中嵌套同步，锁却不同
=================================================================================
线程间通信
=================================================================================
线程间通讯：
多个线程在操作同一个资源，但是操作的动作不同
===========================================================
示例：
class Res
{
	private String name;
	private String sex;
	private boolean flag = false;
	private Lock = new ReentrantLock();
	private Condition condition_pro = lock.newCondition();
	private Condition condition_con = lock.newCondition();
	public  void set (String name,String sex) throws InterruptedException
	{	 	lock.lock();
			while (flag)
				condition_pro.await();
						this.name = name;
						this.sex =sex;
						flag = true;
						condition_con.signal();
					finally
					{
						lock.unlock();
					}
						
	}
	public synchronized void out()
	{	lock.lock(); 
		try
		{
			while(!flag)
				condition_con.await();
			System.out.println(Thread.currentThread().getName()+this.name+this.sex)
			flag = flase;
			condition_pro.signal();
		}
		finally
		{
			lock.unlock();
		}
	}
}
class Input implements Runnable
{
	private Res r;
	Input(Res r)
	{
		this.r = r;
	}
	public void run()
	{
		int x = 0;
		while(true)
		{	    
			try
			{
				if (x==0)
				{	
					r.set = ("mike","male");
				}
					else
					{	
						r.set = ("丽丽","女女"）;
					}
			x= (x+1)%2;
			}
				catch(InterruptedException e)
				{}
		
			}
		}
	}
}

class Output implements Runnable
{
	private Res r;
	Output (Res r)
	{	
		this.r =r;
	}
	public void run()
	{	
		{	
			while (true)
			{
				try
				{
					r.out();
				}
				catch(InterruptedException e)
			}
		
		}
	}
	
}

class InputOutputDemo
{
	public static void main(Strin[] args)
	{
		Res r = new Res();
		new Thread(new Input(r)).start();
		new Thread(new output(r)).start();
	}
}
/*
wait() 
notify()
notifyAll()
都使用在同步中，因为要对持有锁的线程操作，所以要使用在同步中，因为只有同步才具有锁
 
为什么这些操作线程的方法要定义在Object类中呢：
因为这些方法在操作同步中线程时，都必须要标识它们所操作的线程的锁
只有同一个锁上的被等待线程，可以被同一个锁上notify唤醒
不可以对不同锁中的线程进行唤醒

也就是说等待和唤醒必须是同一个锁

而锁可以使任意对象，所以被任意对象调用的方法定义在Object类中

若线程数大于两个，必须使用while判断并且notifyAll()

JDK1.5中提供了多线程升级解决方案，将同步Synchronized替换成现实Lock操作

将Object中的wait,notify,notifyALL替换了condition对象
该对象可以Lock锁进行获取  

该示例中实现了本方只唤醒对方操作

注意有了lock必须finally中unlock，释放锁的操作一定要执行
*/
=========================================================
停止线程
===========================================================
stop方法过时，用run方法结束
只要控制住循环，就可以子线程中的让run方法里的循环结束，也就是线程结束
特殊情况：
当线程处于冻结状态，就不会读取到标记，那么线程就不会结束

当没有指定的方式让冻结的线程恢复到运行状态时，这时需要对冻结状态进行清除，强制让线程恢复到运行状态
这时可以操作标记让让线程结束

==========================================================
class StopThread implements Runnable
{
	private boolean flag = true;
	public void run()
	{	
		while(flag)
		{	
		/* try
			{
				wait();
			}
			catch(InterruptedException e)
			{
				System.out.println(Thread.currentThread.getName+"....Exception");
				flag = false;
			}
		
		*/
		
		
			System.out.println(Thread.currentThread().getName()+".....run");
		}
	}
	public void chageFlag()
	{
		flag = false;
	}
	
}
class StopThreadDemo
{
	public static void main(String[] args)
	{
		StopThread st = new StopThread();
		t1.setDaemon(true);
		t2.setDaemon(true);
		Thread t1 = new Thread(st);
		Thread t2 = new Thread(st);
		t1.start();
		t2.start();
		int num = 0;
		while(true)
		{
			if (num++ == 60)
			{
				st.changeFlag();
				break;
			}
			System.out.println(Thread.currentThread().getName()+".......run");
		}
	}
}
===================================================================================================
setDaemon(true);将该线程变为后台线程（守护线程），在线程开启前使用
join()方法:
当A线程执行到了B线程.join()方法时，A就会等待，等B线程都执行完A才会执行
join()可以用于临时加入线程

线程优先级1-10，通过方法setPriority()来调整


=====================================================================================================
class StopThread implements Runnable
{
	private boolean flag = true;
	public void run()
	{	
		while(flag)
		{	
		System.out.println(Thread.currentThread().getName()+".....run");
		//Thread.yield();临时释放该线程执行权，可以稍微减缓该线程的出现频率，使其不会连续获得执行权
		}
	}
	public void chageFlag()
	{
		flag = false;
	}
	
}
class StopThreadDemo
{
	public static void main(String[] args)
	{
		StopThread st = new StopThread();
		t1.setDaemon(true);
		t2.setDaemon(true);
		// t1.setPriority(Thread.MAX_PRIORITY);设置t1线程优先级最高
		Thread t1 = new Thread(st);
		Thread t2 = new Thread(st);
		t1.start();
		t2.start();
		int num = 0;
		while(true)
		{
			if (num++ == 60)
			{
				break;
			}
			System.out.println(Thread.currentThread().getName()+".......run");
		}
	}
}
=========================================================
当某些代码需要同时被执行时，可以用多线程执行，可以用匿名类完成，使代码更简洁
=================================
class ThreadTest
{
	public static void main(String[] args)
	{
		new Thread()
		{
			public void run()
			{
				for (int i = 0;i<100;i++)
				{
					System.out.prinln(Thread.currentThread().getName()+"....."+x);
				}
			}
		}.start();
		
		for (int i = 0;i<100;i++)
			{
				System.out.prinln(Thread.currentThread().getName()+"....."+x);
			}
		Runnable r = new Runnable()
		{
			public void run()
			{
				for (int i = 0;i<100;i++)
				{
					System.out.prinln(Thread.currentThread().getName()+"....."+x);
				}
			}
		};
			new Thread(r).start();
	}
}
=========================================================================================================
字符串一旦被初始化就不可以被改变
=====================================================================================================
class StringDemo
{
	public static void main(String [] args)
	{
		String s1 = "abc";   //   这句是定义一个String变量s，jvm会先去常量字符串池中找有没有”abc”，有的话就把s指向”abc”，没有就会先在池中创建一个，再让s指向”abc”。 
		s1 = "kk";           //   s1指向kk对象，abc对象依旧存在于内存中
		String s2 = new String("abc");// 这句是先定义一个String变量s，然后在内存中分配新的空间”abc”再让s指向这个内存地址
		String s3 = "abc";
		String s4 = new String("abc");
		/*
		s1和s2有什么区别？
		前者是java中标准的对象创建方式，其创建的对象将直接放置到堆中，每调用一次就会在堆上面创建一个新的对象；
		后者则会在栈中创建一个对象引用变量str，然后查看字符串池中是否存在”XXX”，如果没有，则将”XXX”存放字符串池，并令引用变量str指向它；
		如果已经有”XXX”，则直接令str指向它。这样充分利用了栈的数据共享优点，当然也可能是一个陷阱，对象很有可能没有创建，只不过指向一个先前已经创建的对象；而new()方法则能保证每次都指向新创建象。 
		*/
		//System.out.print(s1 == s2) 为假，s1和s2指向不同对象，地址不一样
		//System.out.print(s1 == s3) 为真，s1和s3指向的是字符串池中的同一个对象
		//System.out.print(s1.equals(s2))为真，String类中复写了Object类中的equals方法，该方法用于判断字符串是否相同
		//System.out.println(str2 == str4);
		
	}
}
==============================================================================================
String类适用于描述字符串事物
该类中提供了多个方法对字符串进行操作
常见的操作有哪些?

1获取
1.1获取字符串长度
int length();

1.2查找某个位置上的字符
char charAt(int index)

1.3获取ch字符在字符串中第一次出现的位置
int indexOf(int ch); 没找到返回-1
int indexOf(int ch,int fromIndex);从fromIndex位置开始查找，重载了indexOf方法
int lastindexOf(int cha) 反向索引ch字符第一次出现的位置(从后往前找)

获取str一字符串在字符串中的位置
int indexOf(String str);
int indexOf(String str,int fromIndex);从fromIndex位置开始查找，重载了indexOf方法

2判断
2.1字符串中是否包含某一个子串
boolean contains(str);
		indexOf(str)；也可以用，通过返回值是-1则不包含，否则包含。该方法既可以判断又可以获取出现的位置

2.2字符串中是否有内容
boolean isEmpty(str);//判断长度是否为0

2.3字符串是否以指定内容开头
boolean startsWith(str)；

2.4字符串是否以指定内容结尾
boolean endsWith(str);

2.5忽略大小写比较
boolean equalsIgnoreCase();

3转换

3.1将字符数组转换成字符串
构造函数：String(char[])
		  String(char[],offset,count) //offset是起始角标位，count是个数
char [] arr = {'a','b','c','d','e','f'};
String s = new String (arr);		  
		 
静态方法：static String copyValueOf(char[]);
		  static String copyValueOf(char[],offset.count);
		  static String valueOf(char[]);
3.2将字符串转换成字符数组
		  char[] tocharArray()
		  
3.3将字节数组转换成字符串
          String(byte[])
		  String(byte[],offset,count) //offset是起始角标位，count是个数
		  
3.4将字符串转换成字节数组
          byte[] getBytes()//字符串和字节数组在转换过程中是可以指定编码表的
		  
3.5将基本数据类型转换成字符串
static String valueOf(int)
static String valueOf(double)
3+""//String.valueOf(3);

4.替换
	String replace(oldchar,newchar )//replace返回的是一个新字符串，如果要替换的字符不存在，返回的还是原串
	replace(oldstring,newstring) //替换字符串中的某一小串
	
5.切割
String[] split(regex);以regex为分割标志,返回的是一个字符串数组！

6.子串
获取字符串中的一部分
String substring(begin)
String substring(begin,end)//包含begin角标位，不包含end角标位

7.转换，去除空格，比较
7.1 将字符串转成大写或小写
String toUpperCase()
String tolowerCase()

7.2将字符串两端的多个空格去除
String trim()

7.3对两个字符串进行自然顺序的比较
int compareTo(string) 
String s1 = "abc";
String s2 = "acc";
s1.compareTo(s2); //正数表示s1>s2 0表示相等，负数表示小于
java中从头到尾 一般含头不含尾，尾巴是.length
===========================================================
StringBuffer是字符串缓冲区	
1.是一个容器，而且长度是可变化的
2.可以直接操作多个数据类型
3.最终会通过toString()方法变成字符串
1.存储
StringBuffer append():将指定数据作为参数添加到已有数据结尾处 append内可以是int float boolean
StringBuffer insert(index,数据)：将数据插在index位上

2.删除
StringBuffer delete(int start,int end)()删除缓冲区中的数据包含start,不包含end
StringBuffer deletecharAt(int index)删除指定位置的数据

3.查找获取
char charAt(int index)
int indexOf(String str)
int lastIndexOf(String str)
int length()
String substring(int start,int end)

4.修改
StringBuffer replace(int start,int end,String str)包含start不包含end的部分用字符串str替换掉
void setChatAt(int index,char ch) 

5.翻转
StringBuffer reverse()

6将缓冲区中的指定数据存储到指定字符数组中
void getChars(int src begin,int src end ,char[] dst,int dstBegin)

JDK1.5之后出现StringBulider
StringBuffer是线程同步
StringBuilder是线程不同步
多线程用StringBuffer,单线程用StringBuilder
以后开发建议使用StringBuilder

JDK升级三个因素：
提高效率
简化书写
提高安全性
=======================================================================
基本数据类型对象包装类
int Integer
long Long
float Float
double Double
boolean Boolean
char Charcter
基本数据类型对象包装类的最常见作用就是用于基本数据类型和字符串之间做转换

基本数据类型转成字符串

基本数据类型+“”

基本数据类型.toString(基本数据类型值)

如：Integer.toString(34);//将34整数变成“34”

字符串转成基本数据类型
xxx a = Xxx.parseXxx(String);
int a = Integer.parseInt("123");//必须传入数字格式的字符串,静态调用方式
double a = Double.parseDouble("123.45")
boolean a = Boolean.parseBoolean("true")
Integer i = new Integer("123");
int num = i.intValue();//动态调用方式

十进制转换成其他进制
toBinaryString(String);
toHexString(String);
toOctalString(String);

其他进制转换成十进制
parseInt(String s,int radix) radix是“几进制”

JDK1.5版本之后出现的新特性
Integer i = new Integer(4);
Integer x = 4;//1.5版本之后可以这么写，x是引用数据类型，4是对象 自动装箱 //Integer x = null
x = x /* x.intValue() */+ 2;//进行了自动拆箱，变成了int类型和2进行加法运算，

Integer m = 128;
Integer n = 128;
(m == n)为false
Integer a = 127;
Integer b = 127;
(a == b)为true

因为当数值在byte范围内时，对于新特性，如果该数值已经存在则不会再开辟新的空间（byte范围：-128~127）
======================================================================================================
集合类
Colletion(接口)

子接口 List 包含类：ArrayList LinkedList Vector

ArrayList：底层使用的是数组数据结构，特点查询速度快，但是增删慢，线程不同步，相比Vector效率更高
		   初始容量为10，当元素个数超过10时，新建一个50%延长的数组，把原数据copy到新数组中，比Vector更节省内存空间
			
LinkedList：底层使用链表数据结构，特点增删速度很快，查询稍慢
            初始容量为10，当元素个数超过10时，新建一个100%延长的数组，把原数据copy到新数组中

Vector: 底层使用数组数据结构，线程同步
		枚举是是Vector的特有取出方法，Vector和Iterator方法实现功能相同
		Enumeration en = v.elements(); 
		en.hasMoreElements 与 it.hasNext类似

子接口 Set  包含类：Hashset TreeSet

为什么会出现这么多的容器
因为每个容器对数据的存储方式都不同，这种存储方式称为数据结构
/*
add方法的参数类型是obj，以便于接受任意类型对象
集合中存储的是对象的引用（亦可称之为该对象在内存中的地址）
*/
import java.util.*;
class ColletionDemo
{
	public static void main(String[] args)
	{
		ArrayList al_1 = new ArrayList();
		
		//增加元素
		al_1.add("java01")；
		al_1.add("java02")；
		al_1.add("java03")；
		al_2.add("java04")；
		al_2.add("java02")；
		al_2.add("java03")；

		
		//获取个数，集合长度
		System.out.println(al.size());
		
		//删除元素
		al.remove("java01");
		al.claer()//清空集合
		
		//判断元素
		System.out.println(al.contains("java03"));
		System.out.println(al.isEmpty());
		
		//取交集
		al_1.retainALL(al_2);
		/保留al_1中与al_2有交集的部分
		
		//迭代器
		Iterator it = al.iterator();
		while(it.hasNext()) //如果仍有元素可以迭代，返回true
			System.out.println(it.next()); //返回迭代的下一个元素
			
		for(Iterator it = al.iterator();it.hasNext();)//for循环实现方式，更节省内存空间，建立完it对象后即释放
			System.out.println(it.next());
		
		//什么是迭代器：其实就是取出元素的方式
		/*
			集合中的内容需要取出，把取出方式定义在集合内部，
			这样取出方式就可以直接访问集合内容的元素，取出方式被定义成了内部类
			
			而每一个容器的数据结构不同，取出的动作细节不一样，但都有共性内容：
			判断和取出，将共性抽取
			
			这些内部类都符合一个规则，该规则是Iterator，
			如何获取集合的取出对象呢？
			集合通过对外提供的itreator()方法 
		*/
	}
}
======================================================================
Colletion
	|--List:元素有序可以重复,该集合体系有索引
	|--Set：元素无序，不可重复
List:
	特有方法，凡是可以操作角标的方法都是该体系的特有方法
	
增：add(index,element)
	addAll(index,Colletion)

删：remove(index)

改：set(index,element)

查：get(index)
	subList(from,to)(包含头不包含尾)
	listIterator()

列表迭代器：
在迭代过程中（在遍历过程中）准备删除或添加元素
ListIterator是Iterator的子接口
在迭代时不可以不可以通过集合对象的方法操作集合中的元素，会发生ConcurrentModificationException
Iterator方法只能对元素进行判断，取出，删除
想要进行添加或修改，需用List集合的ListIterator方法进行获取

ListIterator li = al.listiterator();
		while(it.hasNext()) //如果仍有元素可以迭代，返回true
		{
			Object obj = li.next();
			if (obj.equals("java 02"))
				{
					li.add("java 002");
					//li.set("java 007");
				}
		}
			System.out.println(it.next()); //返回迭代的下一个元素
		
======================================================================================================================
linkedList
==================================================================================================================
import java.util.*;
/*
LinkedList特有方法：
addFirst()
addLast()

getFirst()//能够获取元素，但不删除，集合为空时会抛异常
getLast()


removeFirst()//也能够获取元素，但是元素被删除，集合为空时会抛异常
removeLast() 


JDK1.6后用替代方法

offerFirst()
offerLast()

peekFirst()//能够获取元素，但不删除,集合中没有元素则返回null
peekLast()

pollFirst()//能够获取元素，并且删除,集合中没有元素则返回null
pollLast()

*/
LinkedList link = new LinkedList();
link.add("java01");
link.add("java02");
link.add("java03");			
			